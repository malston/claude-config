#!/usr/bin/env bash
# ABOUTME: Entry point for managing Claude Code devcontainer sandboxes.
# ABOUTME: Dispatches to subcommands: start, exec, claude, attach, list, stop, cleanup.

set -euo pipefail

SCRIPT_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
SANDBOX_BASE_DIR="$HOME/.claude-sandboxes"
SANDBOX_STATE_DIR="$SANDBOX_BASE_DIR/state"
SANDBOX_REPOS_DIR="$SANDBOX_BASE_DIR/repos"
SANDBOX_WORKSPACES_DIR="$SANDBOX_BASE_DIR/workspaces"
DEVCONTAINER_BASE="$REPO_DIR/devcontainer-base"
PROFILES_DIR="$HOME/.claudeup/profiles"

# --- Helpers ---

die() {
    echo "error: $*" >&2
    exit 1
}

generate_sandbox_id() {
    uuidgen | tr '[:upper:]' '[:lower:]'
}

# Creates or refreshes a bare clone for the given source project.
# Outputs the bare repo path on stdout.
ensure_bare_repo() {
    local source_project="$1"
    local project_name="$2"
    local bare_repo_name="${project_name}.git"
    local bare_repo_path="$SANDBOX_REPOS_DIR/$bare_repo_name"
    local source_marker="sandbox-source-project"

    mkdir -p "$SANDBOX_REPOS_DIR"

    if [[ -d "$bare_repo_path" ]]; then
        # Verify source matches
        local stored_source=""
        if [[ -f "$bare_repo_path/$source_marker" ]]; then
            stored_source=$(<"$bare_repo_path/$source_marker")
        fi

        if [[ "$stored_source" != "$source_project" ]]; then
            # Source mismatch -- different project with same name.
            # Append hash suffix to disambiguate.
            local hash_suffix
            hash_suffix=$(printf '%s' "$source_project" | shasum -a 256 | cut -c1-8)
            bare_repo_name="${project_name}-${hash_suffix}.git"
            bare_repo_path="$SANDBOX_REPOS_DIR/$bare_repo_name"

            if [[ -d "$bare_repo_path" ]]; then
                # Already exists with hash suffix, verify it matches
                stored_source=""
                if [[ -f "$bare_repo_path/$source_marker" ]]; then
                    stored_source=$(<"$bare_repo_path/$source_marker")
                fi
                if [[ "$stored_source" != "$source_project" ]]; then
                    die "bare repo collision: $bare_repo_path exists for a different project"
                fi
            fi
        fi
    fi

    if [[ -d "$bare_repo_path" ]]; then
        # Refresh existing bare clone
        echo "Refreshing bare clone: $bare_repo_path" >&2
        if ! git -C "$bare_repo_path" fetch --all --prune >&2; then
            # Fetch failed -- try updating origin URL from source
            local current_upstream
            current_upstream=$(git -C "$source_project" remote get-url origin 2>/dev/null || true)
            if [[ -n "$current_upstream" ]]; then
                echo "Updating origin URL and retrying fetch..." >&2
                git -C "$bare_repo_path" remote set-url origin "$current_upstream"
                git -C "$bare_repo_path" fetch --all --prune >&2 || true
            fi
        fi
        # Fetch local branches from source project
        git -C "$bare_repo_path" fetch "$source_project" '+refs/heads/*:refs/heads/*' >&2 || true
    else
        # Create new bare clone
        local upstream_url
        upstream_url=$(git -C "$source_project" remote get-url origin 2>/dev/null || true)

        if [[ -n "$upstream_url" ]]; then
            echo "Cloning bare repo from upstream: $upstream_url" >&2
            if git clone --bare "$upstream_url" "$bare_repo_path" >&2; then
                # Capture local branches not yet pushed
                echo "Fetching local branches from source project..." >&2
                git -C "$bare_repo_path" fetch "$source_project" '+refs/heads/*:refs/heads/*' >&2 || true
            else
                echo "Upstream clone failed, falling back to local project..." >&2
                rm -rf "$bare_repo_path"
                git clone --bare "$source_project" "$bare_repo_path" >&2
            fi
        else
            echo "Cloning bare repo from local project (no upstream)..." >&2
            git clone --bare "$source_project" "$bare_repo_path" >&2
        fi

        # Record source project path
        printf '%s' "$source_project" > "$bare_repo_path/$source_marker"
    fi

    printf '%s' "$bare_repo_path"
}

# Derives a human-readable display name for the sandbox workspace directory.
# Outputs the display name on stdout.
compute_display_name() {
    local project_name="$1"
    local profile="$2"
    local user_name="$3"
    local sandbox_id="$4"
    local display_name

    if [[ -n "$user_name" ]]; then
        display_name="$user_name"
    else
        display_name="${project_name}-${profile}"
    fi

    # Disambiguate against existing directories and state metadata
    local needs_suffix=false
    if [[ -d "$SANDBOX_WORKSPACES_DIR/$display_name" ]]; then
        needs_suffix=true
    else
        for meta in "$SANDBOX_STATE_DIR"/*.json; do
            [[ -f "$meta" ]] || continue
            if [[ "$(jq -r .display_name "$meta")" == "$display_name" ]]; then
                needs_suffix=true
                break
            fi
        done
    fi
    if [[ "$needs_suffix" == true ]]; then
        display_name="${display_name}-${sandbox_id:0:8}"
    fi

    # Validate display name contains only safe characters
    if [[ ! "$display_name" =~ ^[A-Za-z0-9._-]+$ ]]; then
        die "invalid sandbox name '$display_name' -- allowed characters: A-Z, a-z, 0-9, '.', '_', '-'"
    fi
    if [[ "$display_name" == "." || "$display_name" == ".." || "$display_name" == .* ]]; then
        die "invalid sandbox name '$display_name' -- name must not start with '.'"
    fi

    printf '%s' "$display_name"
}

usage() {
    cat <<EOF
Usage: claude-sandbox <command> [options]

Commands:
  start      Create and start a sandbox devcontainer
  exec       Run a command inside a running sandbox
  claude     Launch Claude Code inside a running sandbox
  attach     Attach a terminal to a running sandbox
  list       List sandboxes and their status
  stop       Stop a running sandbox
  cleanup    Remove a sandbox (worktree, container, volumes)

Options:
  -h, --help    Show this help message

Start options:
  --project <path>          Project directory (required, must be a git repo)
  --profile <name>          Profile name (required, must exist in ~/.claudeup/profiles/)
  --branch <name>           Git branch name (default: sandbox/<profile>)
  --name <name>             Display name for the sandbox (default: <project>-<profile>)
  --feature <name[:ver]>    Devcontainer feature to include (repeatable)
  --base-profile <name>     Apply a base profile first, then add --profile on top

Sandbox resolution (--sandbox):
  Sandboxes can be identified by display name, UUID, partial UUID prefix,
  project name, or profile name. If ambiguous, matching sandboxes are listed.
  When run from inside a worktree, the sandbox is inferred automatically.

Examples:
  claude-sandbox start --project ~/code/myapp --profile default
  claude-sandbox start --project . --profile docker --branch sandbox/docker-work
  claude-sandbox start --project ~/code/myapp --profile full --name myapp-full
  claude-sandbox start --project ~/code/myapp --profile default --feature node:20
  claude-sandbox list
  claude-sandbox exec --sandbox myapp-default -- ls -la
  claude-sandbox exec --sandbox a1b2c3d4 -- bash
  claude-sandbox stop --sandbox myapp-default
  claude-sandbox cleanup --sandbox myapp-default
EOF
}

# --- Argument parsing for 'start' subcommand ---

parse_start_args() {
    START_PROJECT=""
    START_PROFILE=""
    START_BRANCH=""
    START_FEATURES=()
    START_BASE_PROFILE=""
    START_NAME=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project)
                [[ $# -ge 2 ]] || die "--project requires a value"
                START_PROJECT="$2"
                shift 2
                ;;
            --profile)
                [[ $# -ge 2 ]] || die "--profile requires a value"
                START_PROFILE="$2"
                shift 2
                ;;
            --branch)
                [[ $# -ge 2 ]] || die "--branch requires a value"
                START_BRANCH="$2"
                shift 2
                ;;
            --feature)
                [[ $# -ge 2 ]] || die "--feature requires a value"
                START_FEATURES+=("$2")
                shift 2
                ;;
            --base-profile)
                [[ $# -ge 2 ]] || die "--base-profile requires a value"
                START_BASE_PROFILE="$2"
                shift 2
                ;;
            --name)
                [[ $# -ge 2 ]] || die "--name requires a value"
                START_NAME="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                die "unknown option: $1"
                ;;
        esac
    done

    [[ -n "$START_PROJECT" ]] || die "--project is required"
    [[ -n "$START_PROFILE" ]] || die "--profile is required"

    # Default branch name
    if [[ -z "$START_BRANCH" ]]; then
        START_BRANCH="sandbox/$START_PROFILE"
    fi
}

validate_start_args() {
    # Resolve project path to absolute
    if [[ ! -d "$START_PROJECT" ]]; then
        die "project path does not exist: $START_PROJECT"
    fi
    START_PROJECT="$(cd "$START_PROJECT" && pwd -P)"

    # Verify it's a git repo
    if ! git -C "$START_PROJECT" rev-parse --git-dir >/dev/null 2>&1; then
        die "project path is not a git repository: $START_PROJECT"
    fi

    # Verify profile exists
    if [[ ! -f "$PROFILES_DIR/$START_PROFILE.json" ]]; then
        die "profile not found: $PROFILES_DIR/$START_PROFILE.json"
    fi

    # Verify base profile exists (if provided)
    if [[ -n "$START_BASE_PROFILE" ]] && [[ ! -f "$PROFILES_DIR/$START_BASE_PROFILE.json" ]]; then
        die "base profile not found: $PROFILES_DIR/$START_BASE_PROFILE.json"
    fi

    # Verify devcontainer CLI is available
    if ! command -v devcontainer >/dev/null 2>&1; then
        die "devcontainer CLI not found on PATH (install: npm install -g @devcontainers/cli)"
    fi

    # Verify Docker is running
    if ! docker info >/dev/null 2>&1; then
        die "docker is not running (start Docker Desktop or the docker daemon)"
    fi

    # Verify bind mount sources exist (Docker creates missing paths as
    # root-owned directories, which breaks file-targeted mounts)
    if [[ ! -d "$HOME/.claude-mem" ]]; then
        die "~/.claude-mem directory not found (create it: mkdir ~/.claude-mem)"
    fi
    if [[ ! -f "$HOME/.claude.json" ]]; then
        die "~/.claude.json not found (run claude once to create it)"
    fi
    if [[ ! -f "$HOME/.claude/settings.json" ]]; then
        die "~/.claude/settings.json not found (run claude once to create it)"
    fi
    if [[ ! -d "$HOME/.claudeup/local" ]]; then
        die "~/.claudeup/local directory not found"
    fi
    if [[ ! -d "$HOME/.claudeup/profiles" ]]; then
        die "~/.claudeup/profiles directory not found (create it: mkdir -p ~/.claudeup/profiles)"
    fi
}

# --- Feature resolution ---

# Builds the JSON features block from --feature flags.
# Each flag is "name" or "name:version". Looks up the feature OCI reference
# in features.json and falls back to the default_version when no version is given.
build_features_json() {
    local features_file="$DEVCONTAINER_BASE/features.json"
    local result=""
    local sep=""

    for spec in "${START_FEATURES[@]}"; do
        local name="${spec%%:*}"
        local version="${spec#*:}"

        # When no colon was present, name == spec == version
        if [[ "$version" == "$name" ]]; then
            version=""
        fi

        # Look up the feature reference in features.json
        local oci
        oci=$(jq -r --arg n "$name" '.[$n].feature // empty' "$features_file")
        if [[ -z "$oci" ]]; then
            die "unknown feature: $name (not found in $features_file)"
        fi

        # Use default_version when caller omitted the version
        if [[ -z "$version" ]]; then
            version=$(jq -r --arg n "$name" '.[$n].default_version // "latest"' "$features_file")
        fi

        result="${result}${sep}    \"${oci}\": {\"version\": \"${version}\"}"
        sep=$',\n'
    done

    printf '%s' "$result"
}

# --- Start implementation ---

start_sandbox() {
    # Step 1 -- generate UUID and derive names
    local project_name
    project_name=$(basename "$START_PROJECT")
    local sandbox_id
    sandbox_id=$(generate_sandbox_id)

    # Step 2 -- create or refresh bare clone
    local bare_repo_path
    bare_repo_path=$(ensure_bare_repo "$START_PROJECT" "$project_name")

    # Step 3 -- compute display name and worktree path
    mkdir -p "$SANDBOX_WORKSPACES_DIR"
    local display_name
    display_name=$(compute_display_name "$project_name" "$START_PROFILE" "$START_NAME" "$sandbox_id")
    local worktree_path="$SANDBOX_WORKSPACES_DIR/$display_name"

    # Step 4 -- create worktree from bare repo
    local branch="$START_BRANCH"

    # Check if branch is already checked out in another worktree
    if git -C "$bare_repo_path" worktree list --porcelain 2>/dev/null | grep -Fq "branch refs/heads/$branch"; then
        local original_branch="$branch"
        branch="${branch}-${sandbox_id:0:8}"
        echo "Branch '$original_branch' already in use, using '$branch' instead"
    fi

    echo "Creating worktree at $worktree_path..."
    if git -C "$bare_repo_path" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
        git -C "$bare_repo_path" worktree add "$worktree_path" "$branch"
    else
        git -C "$bare_repo_path" worktree add "$worktree_path" -b "$branch"
    fi

    # Step 5 -- generate devcontainer.json
    mkdir -p "$worktree_path/.devcontainer"

    # Exclude .devcontainer/ from git tracking in this worktree
    local git_dir
    git_dir=$(git -C "$worktree_path" rev-parse --git-dir)
    local exclude_file="${git_dir}/info/exclude"
    mkdir -p "$(dirname "$exclude_file")"
    if ! grep -qxF '.devcontainer/' "$exclude_file" 2>/dev/null; then
        echo '.devcontainer/' >> "$exclude_file"
    fi

    # Collect template substitution values
    local git_user_name git_user_email github_token context7_api_key
    local claude_config_repo claude_config_branch
    git_user_name=$(git config user.name 2>/dev/null || true)
    git_user_email=$(git config user.email 2>/dev/null || true)
    github_token="${GITHUB_TOKEN:-}"
    context7_api_key="${CONTEXT7_API_KEY:-}"
    claude_config_repo="${CLAUDE_CONFIG_REPO:-}"
    claude_config_branch="${CLAUDE_CONFIG_BRANCH:-main}"

    # Build features block
    local features_block=""
    if [[ ${#START_FEATURES[@]} -gt 0 ]]; then
        features_block=$(build_features_json)
    fi

    # Render template using awk for safe substitution (sed is vulnerable to
    # delimiter injection when values contain special characters like |, &, /).
    local outfile="$worktree_path/.devcontainer/devcontainer.json"

    awk \
        -v project_name="$project_name" \
        -v profile="$START_PROFILE" \
        -v sandbox_id="$sandbox_id" \
        -v display_name="$display_name" \
        -v bare_repo_path="$bare_repo_path" \
        -v home="$HOME" \
        -v git_user_name="$git_user_name" \
        -v git_user_email="$git_user_email" \
        -v github_token="$github_token" \
        -v context7_api_key="$context7_api_key" \
        -v claude_config_repo="$claude_config_repo" \
        -v claude_config_branch="$claude_config_branch" \
        -v base_profile="$START_BASE_PROFILE" \
        -v features="$features_block" \
        '{
            gsub(/\{\{PROJECT_NAME\}\}/, project_name)
            gsub(/\{\{PROFILE\}\}/, profile)
            gsub(/\{\{SANDBOX_ID\}\}/, sandbox_id)
            gsub(/\{\{DISPLAY_NAME\}\}/, display_name)
            gsub(/\{\{BARE_REPO_PATH\}\}/, bare_repo_path)
            gsub(/\{\{HOME\}\}/, home)
            gsub(/\{\{GIT_USER_NAME\}\}/, git_user_name)
            gsub(/\{\{GIT_USER_EMAIL\}\}/, git_user_email)
            gsub(/\{\{GITHUB_TOKEN\}\}/, github_token)
            gsub(/\{\{CONTEXT7_API_KEY\}\}/, context7_api_key)
            gsub(/\{\{CLAUDE_CONFIG_REPO\}\}/, claude_config_repo)
            gsub(/\{\{CLAUDE_CONFIG_BRANCH\}\}/, claude_config_branch)
            gsub(/\{\{BASE_PROFILE\}\}/, base_profile)
            if (features != "") {
                gsub(/\{\{FEATURES\}\}/, features)
            } else {
                # Remove placeholder line so features object is empty: {}
                if (/\{\{FEATURES\}\}/) next
            }
            print
        }' "$DEVCONTAINER_BASE/devcontainer.template.json" > "$outfile"

    # Step 6 -- copy init scripts
    cp "$DEVCONTAINER_BASE/init-claude-config.sh" "$worktree_path/.devcontainer/"
    cp "$DEVCONTAINER_BASE/init-config-repo.sh" "$worktree_path/.devcontainer/"
    cp "$DEVCONTAINER_BASE/init-claudeup.sh" "$worktree_path/.devcontainer/"

    # Step 7 -- launch container
    echo "Starting devcontainer..."
    devcontainer up --workspace-folder "$worktree_path"

    # Step 8 -- save metadata
    mkdir -p "$SANDBOX_STATE_DIR"
    cat > "$SANDBOX_STATE_DIR/${sandbox_id}.json" <<METADATA
{
  "sandbox_id": "$sandbox_id",
  "display_name": "$display_name",
  "project": "$START_PROJECT",
  "project_name": "$project_name",
  "profile": "$START_PROFILE",
  "bare_repo": "$bare_repo_path",
  "worktree": "$worktree_path",
  "branch": "$branch",
  "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
METADATA

    # Step 9 -- report
    echo ""
    echo "Sandbox ready!"
    echo "  Name:     $display_name"
    echo "  ID:       ${sandbox_id:0:8}"
    echo "  Worktree: $worktree_path"
    echo "  Branch:   $branch"
    echo "  Profile:  $START_PROFILE"
    echo ""
    echo "Next steps:"
    echo "  claude-sandbox exec   --sandbox $display_name -- <command>"
    echo "  claude-sandbox claude --sandbox $display_name"
    echo "  claude-sandbox attach --sandbox $display_name"
    echo "  claude-sandbox stop   --sandbox $display_name"
}

# --- Sandbox resolution ---

resolve_sandbox() {
    local query=""

    # Check for --sandbox flag
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --sandbox)
                query="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    local matches=()

    if [[ -n "$query" ]]; then
        # 1. Exact UUID match
        if [[ -f "$SANDBOX_STATE_DIR/${query}.json" ]]; then
            echo "$query"
            return 0
        fi

        # Search all state files for fuzzy matches
        for meta in "$SANDBOX_STATE_DIR"/*.json; do
            [[ -f "$meta" ]] || continue
            local sid dname proj_name prof
            sid=$(jq -r .sandbox_id "$meta")
            dname=$(jq -r .display_name "$meta")
            proj_name=$(jq -r .project_name "$meta")
            prof=$(jq -r .profile "$meta")

            # 2. Display name match
            if [[ "$dname" == "$query" ]]; then
                matches=("$sid")
                break
            fi

            # 3. Partial UUID prefix
            if [[ "$sid" == "$query"* ]]; then
                matches+=("$sid")
                continue
            fi

            # 4. Project name match
            if [[ "$proj_name" == "$query" ]]; then
                matches+=("$sid")
                continue
            fi

            # 5. Profile match
            if [[ "$prof" == "$query" ]]; then
                matches+=("$sid")
                continue
            fi
        done
    else
        # No --sandbox flag: try to infer from cwd
        local cwd
        cwd=$(pwd)
        for meta in "$SANDBOX_STATE_DIR"/*.json; do
            [[ -f "$meta" ]] || continue
            local wt sid
            wt=$(jq -r .worktree "$meta")
            sid=$(jq -r .sandbox_id "$meta")
            if [[ "$cwd" == "$wt"* ]]; then
                matches=("$sid")
                break
            fi
        done
    fi

    if [[ ${#matches[@]} -eq 1 ]]; then
        echo "${matches[0]}"
        return 0
    fi

    if [[ ${#matches[@]} -gt 1 ]]; then
        echo "error: Ambiguous sandbox query: '$query'" >&2
        echo "Matching sandboxes:" >&2
        for sid in "${matches[@]}"; do
            local meta="$SANDBOX_STATE_DIR/${sid}.json"
            local dname proj_name prof
            dname=$(jq -r .display_name "$meta")
            proj_name=$(jq -r .project_name "$meta")
            prof=$(jq -r .profile "$meta")
            printf "  %-30s %-10s %-20s %s\n" "$dname" "${sid:0:8}" "$proj_name" "$prof" >&2
        done
        exit 1
    fi

    # No matches
    echo "error: Could not determine sandbox." >&2
    if [[ -n "$query" ]]; then
        echo "No sandbox matched: '$query'" >&2
    else
        echo "Use --sandbox <name> or run from inside a sandbox worktree." >&2
    fi
    echo "" >&2
    if ls "$SANDBOX_STATE_DIR"/*.json &>/dev/null 2>&1; then
        echo "Available sandboxes:" >&2
        for meta in "$SANDBOX_STATE_DIR"/*.json; do
            local dname sid
            dname=$(jq -r .display_name "$meta")
            sid=$(jq -r .sandbox_id "$meta")
            echo "  $dname (${sid:0:8})" >&2
        done
    else
        echo "No sandboxes found." >&2
    fi
    exit 1
}

# --- Subcommands ---

cmd_start() {
    parse_start_args "$@"
    validate_start_args
    start_sandbox
}

cmd_exec() {
    local sandbox_id
    sandbox_id=$(resolve_sandbox "$@")
    local worktree
    worktree=$(jq -r .worktree "$SANDBOX_STATE_DIR/$sandbox_id.json")

    # Collect args after "--" to pass as the exec command
    local exec_args=()
    local found_separator=false
    while [[ $# -gt 0 ]]; do
        if [[ "$1" == "--" ]]; then
            found_separator=true
            shift
            exec_args=("$@")
            break
        fi
        shift
    done

    if [[ ${#exec_args[@]} -gt 0 ]]; then
        devcontainer exec --workspace-folder "$worktree" "${exec_args[@]}"
    else
        devcontainer exec --workspace-folder "$worktree" bash
    fi
}

cmd_claude() {
    local sandbox_id
    sandbox_id=$(resolve_sandbox "$@")
    local worktree
    worktree=$(jq -r .worktree "$SANDBOX_STATE_DIR/$sandbox_id.json")

    # Collect non-sandbox args to pass to claude
    local claude_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --sandbox) shift 2 ;;
            *) claude_args+=("$1"); shift ;;
        esac
    done

    devcontainer exec --workspace-folder "$worktree" claude "${claude_args[@]}"
}

cmd_attach() {
    if ! command -v code >/dev/null 2>&1; then
        die "VS Code CLI 'code' not found on PATH (see: https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line)"
    fi

    local sandbox_id
    sandbox_id=$(resolve_sandbox "$@")
    local meta="$SANDBOX_STATE_DIR/$sandbox_id.json"
    local worktree display_name
    worktree=$(jq -r .worktree "$meta")
    display_name=$(jq -r .display_name "$meta")

    # Get container ID
    local container_id
    container_id=$(devcontainer exec --workspace-folder "$worktree" hostname 2>/dev/null) || \
        die "could not get container ID -- is the sandbox running?"

    # Encode container ID as hex for VS Code URI
    local hex_id
    hex_id=$(printf '%s' "$container_id" | xxd -p | tr -d '\n')

    code --folder-uri "vscode-remote://attached-container+${hex_id}/workspaces/${display_name}"
    echo "VS Code attached to sandbox: $display_name (${sandbox_id:0:8})"
}

cmd_list() {
    if [ ! -d "$SANDBOX_STATE_DIR" ] || [ -z "$(ls -A "$SANDBOX_STATE_DIR" 2>/dev/null)" ]; then
        echo "No sandboxes found."
        return 0
    fi

    printf "%-30s %-10s %-20s %-15s %s\n" "NAME" "ID" "PROJECT" "PROFILE" "STATUS"
    printf "%-30s %-10s %-20s %-15s %s\n" "----" "--" "-------" "-------" "------"

    for meta in "$SANDBOX_STATE_DIR"/*.json; do
        [ -f "$meta" ] || continue
        local sandbox_id display_name project_name profile worktree status
        sandbox_id=$(jq -r .sandbox_id "$meta")
        display_name=$(jq -r .display_name "$meta")
        project_name=$(jq -r .project_name "$meta")
        profile=$(jq -r .profile "$meta")
        worktree=$(jq -r .worktree "$meta")

        # Check container status
        if docker ps -q --filter "label=devcontainer.local_folder=$worktree" 2>/dev/null | grep -q .; then
            status="running"
        elif [ -d "$worktree" ]; then
            status="stopped"
        else
            status="orphaned"
        fi

        printf "%-30s %-10s %-20s %-15s %s\n" "$display_name" "${sandbox_id:0:8}" "$project_name" "$profile" "$status"
    done
}

cmd_stop() {
    local sandbox_id
    sandbox_id=$(resolve_sandbox "$@")

    local meta="$SANDBOX_STATE_DIR/${sandbox_id}.json"
    local worktree display_name
    worktree=$(jq -r .worktree "$meta")
    display_name=$(jq -r .display_name "$meta")

    echo "Stopping sandbox: $display_name..."
    local container_id
    container_id=$(docker ps -q --filter "label=devcontainer.local_folder=$worktree" 2>/dev/null)
    if [[ -n "$container_id" ]]; then
        docker stop "$container_id" >/dev/null
        echo "Stopped sandbox: $display_name"
    else
        echo "No running container found for sandbox: $display_name"
    fi
}

cmd_cleanup() {
    local sandbox_id
    sandbox_id=$(resolve_sandbox "$@")

    local meta="$SANDBOX_STATE_DIR/${sandbox_id}.json"
    local worktree bare_repo display_name
    worktree=$(jq -r .worktree "$meta")
    bare_repo=$(jq -r .bare_repo "$meta")
    display_name=$(jq -r .display_name "$meta")

    echo "This will:"
    echo "  - Stop the container"
    echo "  - Remove Docker volumes (claude-sandbox-*-$sandbox_id)"
    echo "  - Remove worktree: $worktree"
    echo "  - Remove sandbox metadata"
    echo ""
    read -rp "Continue? [y/N] " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { echo "Aborted."; return 1; }

    echo "Removing container..."
    local container_id
    container_id=$(docker ps -aq --filter "label=devcontainer.local_folder=$worktree" 2>/dev/null)
    if [[ -n "$container_id" ]]; then
        docker rm -f "$container_id" >/dev/null
    fi

    echo "Removing Docker volumes..."
    local volumes
    volumes=$(docker volume ls --format '{{.Name}}' | grep "claude-sandbox-.*-${sandbox_id}$" || true)
    if [[ -n "$volumes" ]]; then
        echo "$volumes" | xargs docker volume rm 2>/dev/null || true
    fi

    echo "Removing worktree..."
    if [[ -d "$worktree" ]] && [[ -d "$bare_repo" ]]; then
        git -C "$bare_repo" worktree remove "$worktree" --force 2>/dev/null || \
            rm -rf "$worktree"
    elif [[ -d "$worktree" ]]; then
        rm -rf "$worktree"
    fi

    echo "Removing metadata..."
    rm -f "$meta"

    echo "Cleaned up sandbox: $display_name"

    # Check if the bare repo has any remaining worktrees
    if [[ -d "$bare_repo" ]]; then
        local worktree_output
        if ! worktree_output=$(git -C "$bare_repo" worktree list --porcelain 2>/dev/null); then
            echo "warning: could not list worktrees for $bare_repo, skipping bare repo cleanup check" >&2
            return 0
        fi
        local worktree_count
        worktree_count=$(echo "$worktree_output" | grep -c "^worktree " || echo "0")
        # A bare repo always lists itself as one worktree
        if [[ "$worktree_count" -le 1 ]]; then
            echo ""
            echo "Bare repo $bare_repo has no remaining worktrees."
            read -rp "Remove bare repo? [y/N] " confirm_bare
            if [[ "$confirm_bare" =~ ^[Yy]$ ]]; then
                rm -rf "$bare_repo"
                echo "Removed bare repo: $bare_repo"
            fi
        fi
    fi
}

# --- Legacy state migration guard ---

migrate_legacy_state() {
    # Detect old-format state files (*.json directly in ~/.claude-sandboxes/)
    local legacy_files=()
    for f in "$SANDBOX_BASE_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        legacy_files+=("$f")
    done

    if [[ ${#legacy_files[@]} -gt 0 ]]; then
        echo "error: Legacy sandbox state detected in $SANDBOX_BASE_DIR/" >&2
        echo "" >&2
        echo "The following sandboxes use the old format:" >&2
        for f in "${legacy_files[@]}"; do
            local name
            name=$(basename "$f" .json)
            echo "  - $name" >&2
        done
        echo "" >&2
        echo "Clean up legacy sandboxes before proceeding:" >&2
        echo "  1. Stop and remove running containers for each sandbox" >&2
        echo "  2. Remove worktrees (git worktree remove ...)" >&2
        echo "  3. Delete state files: rm $SANDBOX_BASE_DIR/*.json" >&2
        exit 1
    fi
}

# --- Main dispatch ---

main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    # Guard against legacy state format
    migrate_legacy_state

    local cmd="$1"
    shift

    case "$cmd" in
        start)    cmd_start "$@" ;;
        exec)     cmd_exec "$@" ;;
        claude)   cmd_claude "$@" ;;
        attach)   cmd_attach "$@" ;;
        list)     cmd_list "$@" ;;
        stop)     cmd_stop "$@" ;;
        cleanup)  cmd_cleanup "$@" ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        *)
            die "unknown command: $cmd (run 'claude-sandbox --help' for usage)"
            ;;
    esac
}

main "$@"
